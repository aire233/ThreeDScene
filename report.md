# OpenGL编程

## 目录

1. [引言](#引言)
2. [项目目标](#项目目标)
4. [方法论](#方法论)
    - [使用技术](#使用技术)
    - [系统架构](#系统架构)
5. [实现过程](#实现过程)
    - [场景构建](#场景构建)
    - [摄像机控制](#摄像机控制)
    - [碰撞检测](#碰撞检测)
    - [后处理滤镜](#后处理滤镜)
    - [用户界面](#用户界面)
    - [天空盒实现](#天空盒实现)
6. [结果](#结果)
    - [功能性](#功能性)
    - [性能](#性能)
    - [截图](#截图)
7. [挑战与解决方案](#挑战与解决方案)
8. [结论](#结论)
9. [未来工作](#未来工作)
10. [参考文献](#参考文献)

## 引言

计算机图形学的发展显著提升了3D场景的渲染和交互方式。本项目旨在使用现代OpenGL开发一个3D场景渲染应用，集成碰撞检测和后处理滤镜等功能。通过使用GLFW、GLAD、GLM和ImGui等库，本项目展示了实时渲染、动态对象交互和视觉效果的实现。

## 项目目标

- **场景构建**：从配置文件加载和渲染多个具有可定制属性的3D对象。
- **摄像机控制**：使用键盘和鼠标输入实现直观的摄像机导航。
- **碰撞检测**：集成碰撞检测，管理动态和静态对象之间的交互。
- **后处理滤镜**：使用帧缓冲和着色器程序对渲染的场景应用视觉效果。
- **用户界面**：利用ImGui显示实时通知并与用户交互。

## 方法论

### 使用技术

- **C++11**：主要编程语言，因其性能和与OpenGL的兼容性。
- **OpenGL 3.3 Core Profile**：用于渲染的图形API。
- **GLFW**：用于创建窗口、上下文和处理输入的库。
- **GLAD**：用于加载OpenGL函数指针的加载器。
- **GLM**：专为图形软件设计的数学库。
- **ImGui**：即时模式GUI库，用于用户界面组件。
- **stb_image**：用于图像加载的头文件库。
- **CMake**：构建系统生成器，用于管理项目编译。

### 系统架构

该应用程序采用模块化架构，将职责分离到不同的组件中：

- **渲染模块**：处理渲染管线的设置和执行，包括对象渲染、天空盒渲染和后处理。
- **输入模块**：管理来自键盘和鼠标的用户输入，控制摄像机移动。
- **碰撞模块**：实现对象之间的碰撞检测逻辑。
- **UI模块**：利用ImGui显示实时通知和未来的交互元素。
- **配置模块**：读取和解析`scene.txt`文件，动态构建场景。

## 实现过程

### 场景构建

场景定义在根目录下的`scene.txt`配置文件中，每一行指定一个3D对象的属性，包括类型（立方体或球体）、位置、颜色、大小、动态状态和速度。应用程序在运行时解析此文件，以在场景中实例化对象。

### 摄像机控制

摄像机导航通过键盘输入（W, A, S, D）进行移动，鼠标移动用于方向调整。摄像机的位置和方向向量根据输入更新，实现自由移动。

### 碰撞检测

使用轴对齐包围盒（AABB）算法实现碰撞检测。每个对象由其最小和最大坐标定义的AABB包围盒。应用程序检查动态对象和静态对象的AABB是否重叠，若检测到碰撞，阻止动态对象穿透静态对象。

### 后处理滤镜

应用程序利用帧缓冲将场景渲染到纹理中，然后通过着色器处理该纹理以应用视觉效果。目前实现了反相滤镜，反转整个场景的颜色，展示了应用各种后处理效果的能力。

### 用户界面

集成ImGui以提供图形用户界面。它显示实时通知，如碰撞警报，增强用户反馈。UI在主渲染通道后绘制在场景之上。

### 天空盒实现

实现了一个天空盒，包围整个场景，提供背景以增强视觉真实感。天空盒使用六张代表立方体每个面的立方体贴图纹理加载。

## 结果

### 功能性

应用程序成功渲染了一个包含多个对象的3D场景，支持摄像机导航和交互。动态对象根据其速度向量移动，并通过碰撞检测与静态对象交互。反相后处理滤镜实时改变场景颜色，碰撞事件触发UI通知。

### 性能

应用程序维持了实时渲染性能，帧率依赖于系统能力和场景复杂度。通过使用AABB优化碰撞检测，确保即使有多个对象也能保持最小的性能开销。

### 截图

*包含展示应用程序不同方面的截图，如初始场景、碰撞时刻以及应用后处理滤镜后的场景。*

## 挑战与解决方案

### 1. 编译错误

**问题**：遇到未声明变量（`width`, `height`）和重复函数定义的错误。

**解决方案**：定义常量`SCR_WIDTH`和`SCR_HEIGHT`替代`width`和`height`。移除重复的函数定义，确保每个函数仅定义一次。

### 2. 碰撞检测失效

**问题**：动态对象未按预期与静态对象发生碰撞。

**解决方案**：调整动态对象的速度方向，确保其移动路径与静态对象相交。通过添加控制台输出验证和调试碰撞检测逻辑，确保AABB重叠被正确检测。

### 3. 摄像机移动过快

**问题**：鼠标滑动后摄像机移动速度过快，导致导航不稳定。

**解决方案**：降低鼠标灵敏度，通过调整鼠标回调函数中的灵敏度参数实现。同时，降低键盘控制的摄像机移动速度，确保移动更加平滑和可控。

### 4. 帧缓冲问题

**问题**：在创建帧缓冲时出现错误，帧缓冲不完整。

**解决方案**：确保帧缓冲设置正确，包括附加颜色和深度模板缓冲。验证纹理格式和帧缓冲的完整性，确保渲染流程顺利进行。

### 5. 集成ImGui

**问题**：初次集成ImGui时出现头文件缺失和UI渲染问题。

**解决方案**：修正包含路径，确保ImGui源文件被正确包含在构建过程中。正确初始化和渲染ImGui，确保其在渲染循环中正常工作。

## 结论

本项目成功实现了一个具有动态和静态对象、碰撞检测、摄像机控制和后处理滤镜的3D场景渲染应用。ImGui的集成提供了有效的实时通知，增强了用户交互体验。模块化的架构确保了系统的可扩展性，为未来添加更多功能如额外的后处理效果或更复杂的碰撞检测算法提供了便利。

## 未来工作

- **增加更多后处理效果**：实现更多滤镜如灰度、模糊和边缘检测，丰富视觉效果。
- **增强碰撞检测**：集成更精确的碰撞算法，如球体-AABB或基于网格的碰撞检测，以适应不同形状的对象。
- **扩展用户界面**：开发更全面的UI，允许用户实时添加、删除或修改场景中的对象。
- **性能优化**：优化渲染和碰撞检测算法，以支持更大规模的场景和更多对象，同时保持高帧率。
- **引入光照和着色**：引入动态光照和着色模型，提高场景的真实感和视觉效果。

## 参考文献

- [LearnOpenGL](https://learnopengl.com/)
- [GLFW](https://www.glfw.org/)
- [GLAD](https://glad.dav1d.de/)
- [GLM](https://glm.g-truc.net/0.9.9/index.html)
- [ImGui](https://github.com/ocornut/imgui)
- [stb_image](https://github.com/nothings/stb)